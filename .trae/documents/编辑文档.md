# Monaco Editor 集成 AISSH 框架方案

## 一、功能概述

### 1.1 核心需求
在现有 AISSH 框架基础上，集成 Monaco Editor 作为核心文件管理中枢，实现以下增强功能：
- **IP 联动触发**：用户在服务器列表（ServerTree）中选中 IP，通过**右键菜单**快速唤起“文件管理”面板。
- **全量信息检索**：通过 SSH 通道实时获取服务器任意路径下的文件列表、属性及内容。
- **深度编辑体验**：集成 Monaco Editor，支持代码高亮、智能补全及远程保存。
- **双向文件传输**：支持大文件分片上传及断点下载功能。
- **AISSH 视觉一致性**：UI 遵循赛博朋克设计规范，保持沉浸式运维体验。

### 1.2 应用场景
- **快速排障**：右键 IP 直接修改 `/etc/` 配置文件或查看 `/var/log/` 日志。
- **代码分发**：直接在 Web 端编辑脚本并上传至目标服务器执行。
- **资产普查**：获取服务器任意路径的信息，进行配置审计。

## 二、技术架构设计

### 2.1 交互架构
```
用户交互 (ServerTree IP 节点)
    ↓ [右键触发 ContextMenu]
文件管理面板 (FileExplorer Panel)
    ↓ [SSH 通道 / SFTP]
远程服务器 (Remote Linux Server)
    ↓ [数据回传]
Monaco Editor / 文件列表渲染
```

### 2.2 核心模块扩展
1. **ContextMenu 交互层**：扩展 ServerTree，监听右键事件并传递当前 ServerID。
2. **SFTP/SSH Service**：后端 NestJS 扩展 SSH2 协议的 SFTP 子系统，处理文件流。
3. **MonacoEditor 组件**：独立编辑器组件，对接 Zustand 中的文件会话。
4. **Task Progress Manager**：管理长耗时的上传/下载任务，支持 UI 进度反馈。

## 三、实现方案

### 3.1 关键组件设计

#### 3.1.1 右键菜单集成 (ServerTree)
```typescript
// components/AISSH/components/ServerTree/ServerNode.tsx
const handleContextMenu = (e: React.MouseEvent) => {
  e.preventDefault();
  showContextMenu({
    x: e.clientX,
    y: e.clientY,
    items: [
      { label: '快速连接', action: 'connect' },
      { label: '文件管理', action: 'open_file_manager', icon: <FileEdit /> },
      { label: '服务器信息', action: 'get_info' }
    ],
    payload: { serverId: server.id, ip: server.ip }
  });
};
```

#### 3.1.2 文件会话管理 (Zustand Store)
```typescript
export interface FileEditorState {
  // 当前激活的服务器 ID
  activeServerId: string | null;
  // 文件浏览器路径
  currentPath: string;
  // 打开的文件 Tabs
  openedFiles: FileSession[];
  
  // 核心 Actions
  navigate: (path: string) => Promise<void>;
  readFile: (path: string) => Promise<string>;
  writeFile: (path: string, content: string) => Promise<void>;
  uploadFile: (file: File) => Promise<void>;
  downloadFile: (path: string) => Promise<void>;
}
```

### 3.2 核心操作流程

#### 3.2.1 唤起文件管理
1. 用户在左侧面板找到目标服务器（IP）。
2. **右键点击** IP 节点，选择“文件管理”。
3. 系统自动建立 SFTP 子会话，并打开中央区域的文件管理面板。

#### 3.2.2 远程文件编辑
1. 双击文件列表中的文件。
2. 调用 `sshService.readFile(path)` 获取 Base64 或文本流。
3. Monaco Editor 渲染内容，用户编辑。
4. 按下 `Ctrl+S`，触发 `sshService.writeFile(path, content)` 回写至服务器。

#### 3.2.3 上传与下载
- **下载**：点击文件旁的下载图标 -> 后端通过 SFTP 流读取 -> 前端触发浏览器 Blob 下载。
- **上传**：点击“上传”按钮或**拖拽文件**至面板 -> 调起文件选择器 -> 分片传输至服务器临时目录并移动至目标路径。

## 四、技术细节与优化

### 4.1 任意信息获取
通过执行 `ls -laR` 或 `stat` 命令结合 SFTP 协议，获取包括权限、所属组、修改时间在内的全量元数据。支持“路径跳转”功能，允许用户手动输入任意 Linux 路径。

### 4.2 编辑器性能优化
- **按需加载**：Monaco Editor 采用动态 import，减少首屏体积。
- **差异保存**：保存时计算 Diff，仅回写修改部分（可选优化项）。
- **自动备份**：本地缓存未保存的草稿，防止网络抖动导致代码丢失。

### 4.3 安全性
- **权限校验**：所有文件操作均需经过后端 SSH2 权限校验。
- **审计记录**：记录所有文件写操作（Edit/Upload/Delete），符合运维审计需求。
    window.open(`mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`);
  };

  return (
    <CyberPanel className="h-full flex flex-col" variant="obsidian">
      {/* 工具栏 */}
      <div className="px-3 py-2 border-b border-white/5">
        <span className="text-xs font-sci text-sci-cyan uppercase tracking-wider">
          File Operations
        </span>
      </div>

      {/* 操作按钮 */}
      <div className="p-3 space-y-2">
        <Button
          size="sm"
          variant="sci-cyan"
          className="w-full"
          onClick={handleFileUpload}
        >
          <Upload size={14} />
          Upload File
        </Button>
        
        <Button
          size="sm"
          variant="secondary"
          className="w-full"
          disabled={!activeSessionId}
          onClick={handleDownload}
        >
          <Download size={14} />
          Download File
        </Button>
        
        <Button
          size="sm"
          variant="secondary"
          className="w-full"
          disabled={!activeSessionId}
          onClick={handleBackup}
        >
          <Mail size={14} />
          Backup File
        </Button>
      </div>

      {/* 文件操作列表 */}
      <div className="flex-1 overflow-y-auto px-3 pb-3">
        <span className="text-xs font-sci text-sci-cyan uppercase tracking-wider">
          Operations
        </span>
        
        <div className="mt-2 space-y-2">
          {fileOperations.length === 0 ? (
            <div className="text-xs text-sci-dim">No operations</div>
          ) : (
            fileOperations.map(operation => (
              <div key={operation.id} className="p-2 bg-sci-base/50 rounded">
                <div className="flex items-center justify-between">
                  <span className="text-xs truncate">{operation.sourcePath}</span>
                  <span className={`text-xs ${
                    operation.status === 'completed' ? 'text-sci-green' :
                    operation.status === 'error' ? 'text-sci-red' :
                    operation.status === 'in-progress' ? 'text-sci-yellow' :
                    'text-sci-dim'
                  }`}>
                    {operation.status}
                  </span>
                </div>
                
                {operation.status === 'in-progress' && operation.progress !== undefined && (
                  <div className="mt-1 h-1 bg-sci-base rounded-full overflow-hidden">
                    <div 
                      className="h-full bg-sci-cyan transition-all duration-300"
                      style={{ width: `${operation.progress}%` }}
                    ></div>
                  </div>
                )}
                
                {operation.error && (
                  <div className="mt-1 text-xs text-sci-red truncate">
                    {operation.error}
                  </div>
                )}
              </div>
            ))
          )}
        </div>
      </div>

      {/* 隐藏的文件输入 */}
      <input
        ref={fileInputRef}
        type="file"
        multiple
        className="hidden"
        onChange={handleFileSelect}
      />
    </CyberPanel>
  );
};
```

#### 3.2.4 文件管理 Store
```typescript
// store/useFileStore.ts
import { create } from 'zustand';
import { FileSession, FileNode, FileOperation } from '../types';

interface FileState {
  // 当前打开的文件会话
  fileSessions: Record<string, FileSession>;
  activeFileSessionId: string | null;
  
  // 文件浏览器状态
  fileBrowserPath: Record<string, string>; // serverId -> currentPath
  fileTreeCache: Record<string, FileNode[]>; // serverId -> fileTree
  
  // 文件操作
  fileOperations: FileOperation[];
  
  // Actions
  openFile: (serverId: string, filePath: string, content: string) => void;
  closeFile: (sessionId: string) => void;
  updateFileContent: (sessionId: string, content: string) => void;
  saveFile: (sessionId: string) => Promise<boolean>;
  setFileBrowserPath: (serverId: string, path: string) => void;
  refreshFileTree: (serverId: string) => Promise<void>;
  addFileOperation: (operation: FileOperation) => void;
  updateFileOperation: (id: string, updates: Partial<FileOperation>) => void;
}

export const useFileStore = create<FileState>((set, get) => ({
  // 初始状态
  fileSessions: {},
  activeFileSessionId: null,
  fileBrowserPath: {},
  fileTreeCache: {},
  fileOperations: [],
  
  // Actions
  openFile: (serverId: string, filePath: string, content: string) => {
    const sessionId = `${serverId}:${filePath}`;
    const session: FileSession = {
      id: sessionId,
      serverId,
      filePath,
      content,
      isModified: false,
      originalContent: content
    };
    
    set(state => ({
      fileSessions: {
        ...state.fileSessions,
        [sessionId]: session
      },
      activeFileSessionId: sessionId
    }));
  },
  
  closeFile: (sessionId: string) => {
    set(state => {
      const newSessions = { ...state.fileSessions };
      delete newSessions[sessionId];
      
      return {
        fileSessions: newSessions,
        activeFileSessionId: state.activeFileSessionId === sessionId ? null : state.activeFileSessionId
      };
    });
  },
  
  updateFileContent: (sessionId: string, content: string) => {
    set(state => {
      const session = state.fileSessions[sessionId];
      if (!session) return state;
      
      return {
        fileSessions: {
          ...state.fileSessions,
          [sessionId]: {
            ...session,
            content,
            isModified: content !== session.originalContent
          }
        }
      };
    });
  },
  
  saveFile: async (sessionId: string): Promise<boolean> => {
    const state = get();
    const session = state.fileSessions[sessionId];
    if (!session) return false;
    
    try {
      // 这里调用 SSH 服务保存文件到服务器
      await saveFileToServer(session.serverId, session.filePath, session.content);
      
      // 更新会话状态
      set(state => ({
        fileSessions: {
          ...state.fileSessions,
          [sessionId]: {
            ...session,
            isModified: false,
            originalContent: session.content
          }
        }
      }));
      
      return true;
    } catch (error) {
      console.error('Failed to save file:', error);
      return false;
    }
  },
  
  setFileBrowserPath: (serverId: string, path: string) => {
    set(state => ({
      fileBrowserPath: {
        ...state.fileBrowserPath,
        [serverId]: path
      }
    }));
  },
  
  refreshFileTree: async (serverId: string) => {
    try {
      // 这里调用 SSH 服务获取文件树
      const fileTree = await fetchFileTreeFromServer(serverId);
      
      set(state => ({
        fileTreeCache: {
          ...state.fileTreeCache,
          [serverId]: fileTree
        }
      }));
    } catch (error) {
      console.error('Failed to refresh file tree:', error);
    }
  },
  
  addFileOperation: (operation: FileOperation) => {
    set(state => ({
      fileOperations: [
        ...state.fileOperations,
        { ...operation, id: operation.id || `op-${Date.now()}` }
      ]
    }));
  },
  
  updateFileOperation: (id: string, updates: Partial<FileOperation>) => {
    set(state => ({
      fileOperations: state.fileOperations.map(op =>
        op.id === id ? { ...op, ...updates } : op
      )
    }));
  }
}));

// 辅助函数
const saveFileToServer = async (serverId: string, filePath: string, content: string): Promise<void> => {
  // 这里调用 SSH 服务保存文件到服务器
  // 实际实现中需要通过 SSH 连接保存文件
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log(`Saving ${filePath} to server ${serverId}`);
      resolve();
    }, 1000);
  });
};

const fetchFileTreeFromServer = async (serverId: string): Promise<FileNode[]> => {
  // 这里调用 SSH 服务获取文件树
  // 实际实现中需要通过 SSH 连接获取文件列表
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log(`Fetching file tree from server ${serverId}`);
      // 返回模拟文件树
      resolve([
        {
          id: '1',
          name: 'home',
          type: 'folder',
          path: '/home',
          children: [
            {
              id: '2',
              name: 'user',
              type: 'folder',
              path: '/home/user',
              children: [
                {
                  id: '3',
                  name: 'config.json',
                  type: 'file',
                  path: '/home/user/config.json',
                  size: 1024
                },
                {
                  id: '4',
                  name: 'script.sh',
                  type: 'file',
                  path: '/home/user/script.sh',
                  size: 2048
                }
              ]
            }
          ]
        }
      ]);
    }, 1000);
  });
};
```

### 3.3 AISSH 主组件集成

#### 3.3.1 修改 AISSH 主组件
```typescript
// AISSH.tsx 修改部分
import React, { useState, useEffect, useRef } from 'react';
import { ServerTree, AddServerModal, PasswordModal, AIChatPanel, sshManager } from './index';
import type { AIChatPanelRef } from './index';
import { useSSHStore } from './store/useSSHStore';
import { useFileStore } from './store/useFileStore';
import { SessionTabs } from './components/SessionTabs';
import { TerminalArea } from './components/TerminalArea';
import { CommandInput } from './components/CommandInput';
import { MonacoEditor } from './components/MonacoEditor';
import { FileBrowser } from './components/FileBrowser';
import { FileOperations } from './components/FileOperations';
import { Tabs, TabsList, TabsTrigger, TabsContent } from '@/components/ui/tabs';

const AISSH: React.FC = () => {
  const { 
    servers, folders, activeSessionId, openSessions, logs, failureCounts,
    setActiveSessionId, setOpenSessions, 
    addLog, updateConnectionStatus, addServer, updateServer, deleteServer,
    addFolder, updateFolder, deleteFolder, resetFailureCount, incrementFailureCount
  } = useSSHStore();

  const {
    fileSessions, activeFileSessionId, openFile, closeFile, updateFileContent, saveFile
  } = useFileStore();

  const [isAddModalOpen, setIsAddModalOpen] = useState<{ parentId: string | null, editData?: any } | null>(null);
  const [passwordPrompt, setPasswordPrompt] = useState<{ serverId: string, serverName: string } | null>(null);
  const [commandToInsert, setCommandToInsert] = useState<string | null>(null);
  const [activeTab, setActiveTab] = useState<'terminal' | 'files'>('terminal');
  const aiChatPanelRef = useRef<AIChatPanelRef>(null);

  const [leftWidth, setLeftWidth] = useState(260);
  const [rightWidth, setRightWidth] = useState(450);
  const isResizingLeft = useRef(false);
  const isResizingRight = useRef(false);

  // ... 其他现有代码保持不变 ...

  const handleFileOpen = (filePath: string, content: string) => {
    if (activeSessionId) {
      openFile(activeSessionId, filePath, content);
      setActiveTab('files');
    }
  };

  const handleFileSave = async (sessionId: string) => {
    return await saveFile(sessionId);
  };

  const handleFileClose = (sessionId: string) => {
    closeFile(sessionId);
  };

  const handleFileDownload = (sessionId: string) => {
    const session = fileSessions[sessionId];
    if (!session) return;
    
    // 创建下载链接
    const blob = new Blob([session.content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = session.filePath.split('/').pop() || 'download';
    a.click();
    URL.revokeObjectURL(url);
  };

  const handleFileBackup = (sessionId: string) => {
    const session = fileSessions[sessionId];
    if (!session) return;
    
    // 创建带时间戳的备份文件名
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupName = `${session.filePath}.${timestamp}`;
    
    // 创建备份文件
    const blob = new Blob([session.content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = backupName;
    a.click();
    URL.revokeObjectURL(url);
    
    // 发送邮件备份
    const subject = `文件备份: ${session.filePath}`;
    const body = `文件名: ${session.filePath}\n备份时间: ${new Date().toLocaleString()}\n\n内容:\n${session.content}`;
    window.open(`mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`);
  };

  return (
    <div className="flex h-screen bg-sci-base text-sci-text font-sci overflow-hidden bg-grid-pattern relative">
      {/* 全局扫描线效果和装饰性边框保持不变 */}
      
      {/* Sidebar Area */}
      <div style={{ width: leftWidth }} className="flex-shrink-0 select-none bg-sci-obsidian/40 backdrop-blur-md border-r border-white/5 relative z-10">
        <ServerTree 
          width={leftWidth}
          servers={servers} 
          folders={folders} 
          activeServerId={activeSessionId} 
          onSelectServer={handleSelectServer} 
          onAddServer={(p) => setIsAddModalOpen({ parentId: p })} 
          onEditServer={(server) => setIsAddModalOpen({ parentId: server.parentId, editData: server })} 
          onDeleteServer={deleteServer} 
          onAddFolder={(p) => addFolder('新建文件夹', p)} 
          onEditFolder={updateFolder} 
          onDeleteFolder={deleteFolder} 
          onMove={(t, id, p) => {
            if(t === 'server') updateServer(id, { parentId: p });
            else updateFolder(id, { parentId: p });
          }}
        />
      </div>

      <div className="w-px bg-sci-cyan/10 hover:bg-sci-cyan cursor-col-resize transition-colors flex items-center justify-center group z-10" onMouseDown={() => { isResizingLeft.current = true; document.body.style.cursor = 'col-resize'; }}>
        <div className="absolute w-4 h-full"></div>
      </div>

      {/* Main Area */}
      <div className="flex-1 flex flex-col min-w-0 bg-transparent relative h-screen">
        <SessionTabs />
        
        {/* 标签页切换 */}
        <div className="bg-sci-obsidian/20 border-b border-white/5">
          <Tabs value={activeTab} onValueChange={(value) => setActiveTab(value as 'terminal' | 'files')}>
            <TabsList className="bg-transparent border-none">
              <TabsTrigger value="terminal" className="data-[state=active]:bg-sci-cyan/10 data-[state=active]:text-sci-cyan">
                Terminal
              </TabsTrigger>
              <TabsTrigger value="files" className="data-[state=active]:bg-sci-cyan/10 data-[state=active]:text-sci-cyan">
                File Editor
              </TabsTrigger>
            </TabsList>
            
            <TabsContent value="terminal" className="flex-1 m-0">
              <TerminalArea 
                commandToInsert={commandToInsert} 
                onAnalyzeLog={handleAnalyzeLogFromTerminal} 
              />
              <CommandInput onInsertCommand={handleInsertCommand} />
            </TabsContent>
            
            <TabsContent value="files" className="flex-1 m-0 flex">
              {/* 文件浏览器 */}
              <div className="w-80 border-r border-white/5">
                {activeSessionId ? (
                  <FileBrowser 
                    serverId={activeSessionId} 
                    onFileOpen={handleFileOpen}
                  />
                ) : (
                  <div className="h-full flex items-center justify-center text-sci-dim">
                    Select a server to browse files
                  </div>
                )}
              </div>
              
              {/* 文件编辑器或文件操作面板 */}
              <div className="flex-1 flex">
                {activeFileSessionId ? (
                  <MonacoEditor
                    session={fileSessions[activeFileSessionId]}
                    onSave={handleFileSave}
                    onClose={handleFileClose}
                    onDownload={handleFileDownload}
                    onBackup={handleFileBackup}
                  />
                ) : (
                  <div className="flex-1 flex">
                    <div className="flex-1 flex items-center justify-center text-sci-dim">
                      Select a file to edit
                    </div>
                    <div className="w-80 border-l border-white/5">
                      <FileOperations
                        serverId={activeSessionId || ''}
                        activeSessionId={activeFileSessionId}
                      />
                    </div>
                  </div>
                )}
              </div>
            </TabsContent>
          </Tabs>
        </div>
      </div>

      <div className="w-px bg-sci-cyan/10 hover:bg-sci-cyan cursor-col-resize transition-colors flex items-center justify-center group z-10" onMouseDown={() => { isResizingRight.current = true; document.body.style.cursor = 'col-resize'; }}>
        <div className="absolute w-4 h-full"></div>
      </div>

      {/* AI Panel Area 保持不变 */}
      
      {/* 模态框保持不变 */}
    </div>
  );
};

export default AISSH;
```

## 四、技术实现细节

### 4.1 Monaco Editor 主题定制
Monaco Editor 主题需要与 AISSH 的科幻风格保持一致，主要通过自定义主题实现：

```typescript
monaco.editor.defineTheme('ai-ssh-dark', {
  base: 'vs-dark',
  inherit: true,
  rules: [
    { token: 'comment', foreground: '6a737d' },
    { token: 'keyword', foreground: 'f97583' },
    { token: 'string', foreground: '9ecbff' },
    { token: 'number', foreground: '79b8ff' },
    // 更多语法高亮规则...
  ],
  colors: {
    'editor.background': '#0d1117',
    'editor.foreground': '#c9d1d9',
    'editorCursor.foreground': '#00f3ff',
    'editor.lineHighlightBackground': '#161b22',
    'editor.selectionBackground': 'rgba(0, 243, 255, 0.2)',
    'editor.inactiveSelectionBackground': 'rgba(0, 243, 255, 0.1)',
    'minimap.background': '#010409',
    'minimap.selectionHighlight': '#00f3ff'
  }
});
```

### 4.2 SSH 文件传输
文件上传和下载功能需要通过 SSH 连接实现，可以使用以下方法：

```typescript
// services/fileService.ts
export class FileService {
  private sshService: SSHService;
  
  constructor(sshService: SSHService) {
    this.sshService = sshService;
  }
  
  async readFile(serverId: string, filePath: string): Promise<string> {
    const connection = this.sshService.getConnection(serverId);
    if (!connection) {
      throw new Error('No active SSH connection');
    }
    
    return new Promise((resolve, reject) => {
      connection.exec(`cat "${filePath}"`, (err, stream) => {
        if (err) {
          reject(err);
          return;
        }
        
        let data = '';
        stream.on('data', (chunk: Buffer) => {
          data += chunk.toString();
        });
        
        stream.on('close', (code: number) => {
          if (code === 0) {
            resolve(data);
          } else {
            reject(new Error(`Failed to read file: ${code}`));
          }
        });
      });
    });
  }
  
  async writeFile(serverId: string, filePath: string, content: string): Promise<void> {
    const connection = this.sshService.getConnection(serverId);
    if (!connection) {
      throw new Error('No active SSH connection');
    }
    
    return new Promise((resolve, reject) => {
      // 使用临时文件方法写入文件
      const tempPath = `/tmp/ai-ssh-${Date.now()}`;
      
      // 首先写入临时文件
      connection.exec(`cat > "${tempPath}" << 'EOF'\n${content}\nEOF`, (err, stream) => {
        if (err) {
          reject(err);
          return;
        }
        
        stream.on('close', (code: number) => {
          if (code !== 0) {
            reject(new Error(`Failed to write temp file: ${code}`));
            return;
          }
          
          // 然后移动到目标位置
          connection.exec(`mv "${tempPath}" "${filePath}"`, (moveErr, moveStream) => {
            if (moveErr) {
              reject(moveErr);
              return;
            }
            
            moveStream.on('close', (moveCode: number) => {
              if (moveCode === 0) {
                resolve();
              } else {
                reject(new Error(`Failed to move file: ${moveCode}`));
              }
            });
          });
        });
      });
    });
  }
  
  async listFiles(serverId: string, path: string): Promise<FileNode[]> {
    const connection = this.sshService.getConnection(serverId);
    if (!connection) {
      throw new Error('No active SSH connection');
    }
    
    return new Promise((resolve, reject) => {
      connection.exec(`ls -la "${path}"`, (err, stream) => {
        if (err) {
          reject(err);
          return;
        }
        
        let data = '';
        stream.on('data', (chunk: Buffer) => {
          data += chunk.toString();
        });
        
        stream.on('close', (code: number) => {
          if (code === 0) {
            const files = parseLsOutput(data, path);
            resolve(files);
          } else {
            reject(new Error(`Failed to list files: ${code}`));
          }
        });
      });
    });
  }
}

function parseLsOutput(output: string, basePath: string): FileNode[] {
  const lines = output.split('\n').filter(line => line && !line.startsWith('total'));
  const files: FileNode[] = [];
  
  for (const line of lines) {
    const parts = line.trim().split(/\s+/);
    if (parts.length < 9) continue;
    
    const permissions = parts[0];
    const owner = parts[2];
    const group = parts[3];
    const size = parseInt(parts[4], 10);
    const name = parts.slice(8).join(' ');
    
    // 跳过 . 和 .. 目录
    if (name === '.' || name === '..') continue;
    
    const isDirectory = permissions.startsWith('d');
    const fullPath = basePath === '/' ? `/${name}` : `${basePath}/${name}`;
    
    files.push({
      id: fullPath,
      name,
      type: isDirectory ? 'folder' : 'file',
      size: isDirectory ? undefined : size,
      permissions,
      owner,
      group,
      path: fullPath
    });
  }
  
  return files;
}
```

### 4.3 文件备份策略
文件备份功能支持多种方式：

1. **本地下载备份**：直接下载文件到本地
2. **邮件备份**：通过邮件客户端发送文件内容
3. **云存储备份**：上传到云存储服务（可扩展）

```typescript
// services/backupService.ts
export class BackupService {
  async downloadBackup(content: string, filename: string): Promise<void> {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupName = `${filename}.${timestamp}`;
    
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = backupName;
    a.click();
    URL.revokeObjectURL(url);
  }
  
  async emailBackup(filename: string, content: string): Promise<void> {
    const subject = `文件备份: ${filename}`;
    const body = `文件名: ${filename}\n备份时间: ${new Date().toLocaleString()}\n\n内容:\n${content}`;
    
    // 打开邮件客户端
    window.open(`mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`);
  }
  
  async cloudBackup(filename: string, content: string, provider: 'aws' | 'gcp' | 'azure'): Promise<string> {
    // 这里可以实现云存储备份
    // 返回备份文件的 URL
    return `https://backup-${provider}.example.com/${filename}`;
  }
}
```

## 五、集成步骤

### 5.1 安装依赖
```bash
# 安装 Monaco Editor
pnpm add monaco-editor

# 安装必要的类型定义
pnpm add -D @types/node

# 安装 UI 组件库（如果尚未安装）
pnpm add @radix-ui/react-tabs
```

### 5.2 配置 Monaco Editor
```typescript
// 在应用入口处配置 Monaco Editor
import * as monaco from 'monaco-editor';

// 配置 TypeScript 支持
monaco.languages.typescript.typescriptDefaults.setCompilerOptions({
  target: monaco.languages.typescript.ScriptTarget.ES2020,
  allowNonTsExtensions: true,
  moduleResolution: monaco.languages.typescript.ModuleResolutionKind.NodeJs,
  module: monaco.languages.typescript.ModuleKind.CommonJS,
  noEmit: true,
  esModuleInterop: true,
  jsx: monaco.languages.typescript.JsxEmit.React,
  reactNamespace: 'React',
  allowJs: true,
  typeRoots: ['node_modules/@types']
});

// 添加额外的类型定义
monaco.languages.typescript.typescriptDefaults.addExtraLib(`
  declare function require(name: string): any;
  declare module 'fs' {
    export function readFile(path: string): string;
    export function writeFile(path: string, content: string): void;
  }
`, 'node_modules/@types/node/index.d.ts');
```

### 5.3 集成到构建流程
```javascript
// vite.config.js 或 webpack 配置
export default {
  optimizeDeps: {
    include: ['monaco-editor/esm/vs/editor/editor.worker']
  },
  worker: {
    format: 'es'
  }
}
```

## 六、使用示例

### 6.1 基本使用流程
1. 连接到 SSH 服务器
2. 切换到 "File Editor" 标签页
3. 在左侧文件浏览器中浏览文件
4. 点击文件名打开编辑器
5. 编辑文件内容
6. 点击保存按钮或按 Ctrl+S 保存文件
7. 可选择下载或备份文件

### 6.2 高级功能
1. **文件上传**：点击 "Upload File" 按钮上传本地文件到服务器
2. **文件备份**：点击 "Backup File" 按钮创建带时间戳的备份文件
3. **多文件编辑**：可以同时打开多个文件进行编辑
4. **语法高亮**：根据文件扩展名自动应用语法高亮
5. **快捷键支持**：支持 Ctrl+S 保存、Ctrl+F 查找等快捷键

## 七、扩展性考虑

### 7.1 插件系统
可以设计插件系统，支持扩展编辑器功能：

```typescript
interface EditorPlugin {
  id: string;
  name: string;
  activate(editor: monaco.editor.IStandaloneCodeEditor): void;
  deactivate(): void;
}

class PluginManager {
  private plugins: Map<string, EditorPlugin> = new Map();
  
  register(plugin: EditorPlugin): void {
    this.plugins.set(plugin.id, plugin);
  }
  
  activate(pluginId: string, editor: monaco.editor.IStandaloneCodeEditor): void {
    const plugin = this.plugins.get(pluginId);
    if (plugin) {
      plugin.activate(editor);
    }
  }
  
  deactivate(pluginId: string): void {
    const plugin = this.plugins.get(pluginId);
    if (plugin) {
      plugin.deactivate();
    }
  }
}
```

### 7.2 协作编辑
可以扩展为支持多人协作编辑：

```typescript
interface CollaborationService {
  joinFileSession(fileId: string, userId: string): void;
  leaveFileSession(fileId: string, userId: string): void;
  sendOperation(fileId: string, operation: any): void;
  onRemoteOperation(fileId: string, callback: (operation: any) => void): void;
}
```

## 八、总结

本方案将 Monaco Editor 无缝集成到现有的 AISSH 框架中，保持了原有的科幻风格和用户体验。通过模块化设计，实现了文件浏览、编辑、上传、下载和备份等功能，并提供了良好的扩展性。

主要特点：
1. **无缝集成**：与现有 AISSH 框架完美融合，保持一致的设计语言
2. **功能完整**：支持文件浏览、编辑、上传、下载和备份
3. **性能优化**：使用 Monaco Editor 的高性能渲染引擎
4. **扩展性强**：预留了插件系统和协作编辑的扩展接口
5. **用户体验**：保持了 AISSH 的科幻风格和交互体验

这个方案不仅满足了基本的文件编辑需求，还为未来的功能扩展提供了良好的基础。